import matplotlib.pyplot as plt
import jax
import jax.numpy as jnp
import equinox as eqx
import pandas as pd
import numpy as np

from .train_utils import inverse_log_transform, standardize, destandardize
from .integrated_gradients import integrated_gradients_all_outputs


def plot_predictions(model: eqx.Module, ys: jnp.ndarray, control_until: int, file_name):
    """
        The code in this method was taken from
        my advisor Umur Can Kaya. No reference
        since the code is in a private repository.

        Plots the ground truth and prediction of 
        a single time series as well as a vertical
        line to indicate when the input ends.
    """
    ts = jnp.linspace(0, 1, 100) 
    plot_ts = jnp.arange(100)
    ys = jnp.log10(1 + ys)

    plot_until = control_until + 14

    control_ys = ys[:control_until]
    control_ys, mean, std = standardize(control_ys)
    y_pred = model(ts=ts, ys=control_ys, control_until=control_until, saveat=ts, train_until=plot_until)
    y_pred = inverse_log_transform(destandardize(y_pred, mean, std))


    plt.rcParams.update({
    "figure.dpi": 300,
    "savefig.dpi": 300,
    "font.size": 10,
    "axes.labelsize": 10,
    "axes.titlesize": 10,
    "legend.fontsize": 9,
    "xtick.labelsize": 9,
    "ytick.labelsize": 9,
    "lines.linewidth": 1.5,
    "lines.markersize": 4,
    })
    fig, ax = plt.subplots(figsize=(5.2, 3.9))  

    
    ax.plot(plot_ts[:plot_until], y_pred[:plot_until], label='Fit')
    ax.scatter(plot_ts, inverse_log_transform(ys),label='Data', marker='.', ls='', c='k')
    ax.set(xlabel=r'$t$ (days)', ylabel=r'$y$', yscale='linear')
    yticks = jnp.linspace(0, 10000, 6)
    
    ymax = max(10000, y_pred.max())  
    ymin = 0
    ax.set_ylim(ymin, ymax)

    
    ax.grid(True)
    ax.legend(loc='upper right')



    ax.axvline(plot_ts[control_until-1], c='k', ls='--', label='control until')

    plt.tight_layout()
    plt.savefig(file_name, dpi=300)
    plt.show()



def plot_temporal_attribution_heatmap(attributions, 
                                      input_labels=None, 
                                      output_labels=None,
                                      title="Input → Output Attribution"):
    """
    Plots a heatmap of temporal attributions (input time relevance for each output time).

    Params:
    
        attributions : 2D array of shape (T_in, T_out) with attribution values.
        input_labels : Labels for input timesteps (y-axis). Can be dates or indices.
        output_labels : Labels for output timesteps (x-axis). Can be dates or indices.
        title : Title for the plot.


    This method was generated by ChatGPT-5 on 26/09/2025

    Initial Prompt:
        '''
            Given a 2D-Array of Input-Output Attributions in a time series 
            forecasting setting, generate a method for plotting a heatmap
            of the attributions using matplotlib.
        '''
    """
    if attributions.ndim != 2:
        raise ValueError(f"Expected 2D array, got {attributions.shape}")

    T_in, T_out = attributions.shape

    if input_labels is None:
        input_labels = [f"Day {i}" for i in range(T_in)]
    if output_labels is None:
        output_labels = [f"Day {j}" for j in range(T_out)]

    # Symmetric color range around zero
    vmin = jnp.min(attributions)
    vmax = jnp.max(attributions)
    max_abs = max(abs(vmin), abs(vmax))    

    fig, ax = plt.subplots(figsize=((8/3)*2, (6/3)*2), dpi=300)
    im = ax.imshow(attributions, aspect="equal", cmap="RdBu_r", vmin=-max_abs, vmax=max_abs)

    plt.colorbar(im, ax=ax, label="Attribution Value")
    step = 5
    ax.set_xticks(range(0, T_out, step))
    ax.set_xticklabels(output_labels[::step], rotation=45, ha="right")
    ax.set_yticks(range(0, T_in, step))
    ax.set_yticklabels(input_labels[::step])
    ax.set_xlabel("Input Time Series")
    ax.set_ylabel("Output Time Series")
    ax.set_title(title)
    plt.tight_layout()
    plt.show()



def plot_ground_truth_with_summed_attributions(attributions, ys):
    """
        Plots ground truth and summed attributions for each input.

        The writing of this method was assisted by ChatGPT-5.1
        Initial prompt on 01/12/2025: 

        '''
            I calculate attributions using the Integrated Gradients method. There is an attribution for each input-output pair, 
            meaning the shape is (input, output). I want to plot the attributions as a bar chart using matplotlib in the same graph as the ground
            truth. I need 2 y-axes since the data have different scales. 

            Please use this existing code for plotting ground truth and prediction as a reference: 

            {See code of 'plot_predictions'}
        '''
    """

    summed_attr = jnp.sum(attributions, axis=0)

    plot_ts = jnp.arange(100)

    fig, ax = plt.subplots(1, 1, figsize=(7/3*2, 6/3*2), dpi=300)  

    ax.scatter(plot_ts, inverse_log_transform(ys),label='Data', marker='.', ls='', c='k')
    ax.set(xlabel=r'$t$ (days)', ylabel=r'$y$', yscale='linear')
    ax.grid(True)
    ax.legend(loc='upper right')

    ax2 = ax.twinx()
    plt.bar(np.asarray(plot_ts)[:attributions.shape[1]], height=np.asarray(summed_attr), width=0.7, alpha=1.0, align='center')
    ax2.set_ylabel('Summed IG attribution')

    ax1_ylim = ax.get_ylim()
    ax2_ylim = ax2.get_ylim()

    # Calculate the ratio of zero position for both axes
    ax1_range = ax1_ylim[1] - ax1_ylim[0]
    ax2_range = ax2_ylim[1] - ax2_ylim[0]

    # Position of zero as fraction of total range
    ax1_zero_frac = -ax1_ylim[0] / ax1_range
    ax2_zero_frac = -ax2_ylim[0] / ax2_range

    # Adjust limits to align zeros
    if ax1_zero_frac > ax2_zero_frac:
        # Expand ax2 bottom
        new_bottom = -ax2_ylim[1] / (1/ax1_zero_frac - 1)
        ax2.set_ylim(bottom=new_bottom)
    else:
        # Expand ax1 bottom
        new_bottom = -ax1_ylim[1] / (1/ax2_zero_frac - 1)
        ax.set_ylim(bottom=new_bottom)
    plt.tight_layout()
    plt.show()

def plot_ig_heatmap_and_barchart(
    attributions,
    ys,
    file_name,
    input_labels=None,
    output_labels=None,
    title_left="Input → Output Attribution",
    title_right="Ground truth with summed attributions"
):
    """
        This function was completely AI-generated. 
        Initial prompt to ChatGPT 5.1 on 19/12/2025

            '''
                {code of IG heatmap function}
                {code of IG bar chart function}

                Please combine these. Both plots should be in one figure 
                next to each other and it should fit nicely into my thesis
                such that it is readable at text width.
            '''
        
        Creates a side-by-side figure:
        (Left) Temporal attribution heatmap (input × output)
        (Right) Ground truth with summed Integrated Gradients attributions

        Designed for thesis-quality figures (high DPI, readable fonts).
    """

    if attributions.ndim != 2:
        raise ValueError(f"Expected 2D array, got {attributions.shape}")

    T_in, T_out = attributions.shape

    if input_labels is None:
        input_labels = [f"{i}" for i in range(T_in)]
    if output_labels is None:
        output_labels = [f"{j}" for j in range(T_out)]

    # ---- Figure layout ----
    fig, axes = plt.subplots(
        1, 2,
        figsize=(14, 5),
        dpi=300,
        gridspec_kw={"width_ratios": [1.1, 1.0]}
    )

    # ======================
    # Left: Attribution heatmap
    # ======================
    vmin = jnp.min(attributions)
    vmax = jnp.max(attributions)
    max_abs = max(abs(vmin), abs(vmax))

    im = axes[0].imshow(
        attributions,
        aspect="equal",   # ← this enforces square cells
        cmap="RdBu_r",
        vmin=-max_abs,
        vmax=max_abs
    )

    cbar = fig.colorbar(im, ax=axes[0], fraction=0.046, pad=0.04)
    cbar.set_label("Attribution value", fontsize=10)

    step = max(1, T_out // 10)
    axes[0].set_xticks(range(0, T_out, step))
    axes[0].set_xticklabels(output_labels[::step], rotation=45, ha="right")

    step_y = max(1, T_in // 10)
    axes[0].set_yticks(range(0, T_in, step_y))
    axes[0].set_yticklabels(input_labels[::step_y])

    axes[0].set_xlabel("Input time step", fontsize=11)
    axes[0].set_ylabel("Output time step", fontsize=11)
    axes[0].set_title(title_left, fontsize=12)

    # ======================
    # Right: Ground truth + summed attributions
    # ======================
    summed_attr = jnp.sum(attributions, axis=0)
    plot_ts = jnp.arange(100)

    ax = axes[1]
    ax.scatter(
        plot_ts,
        inverse_log_transform(ys),
        label="Ground truth",
        marker=".",
        c="k",
        s=12
    )
    ax.set_xlabel(r"$t$ (days)", fontsize=11)
    ax.set_ylabel(r"$y$", fontsize=11)
    ax.grid(True, alpha=0.3)
    ax.legend(loc="upper left", fontsize=9)

    ax2 = ax.twinx()
    ax2.bar(
        np.asarray(plot_ts)[:attributions.shape[1]],
        np.asarray(summed_attr),
        width=0.8,
        alpha=0.6
    )
    ax2.set_ylabel("Summed IG attribution", fontsize=11)

    ax.set_title(title_right, fontsize=12)

    # ---- Align zero lines (important for interpretability) ----
    def align_zero(ax1, ax2):
        y1min, y1max = ax1.get_ylim()
        y2min, y2max = ax2.get_ylim()

        r1 = y1max - y1min
        r2 = y2max - y2min

        z1 = -y1min / r1
        z2 = -y2min / r2

        if z1 > z2:
            ax2.set_ylim(bottom=-(y2max / (1 / z1 - 1)))
        else:
            ax1.set_ylim(bottom=-(y1max / (1 / z2 - 1)))

    align_zero(ax, ax2)

    plt.tight_layout()
    plt.savefig(file_name)
    plt.show()
    
